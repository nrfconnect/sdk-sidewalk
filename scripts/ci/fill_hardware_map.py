"""Script to generate hardware map used by twister based on userdev_conf file."""
import subprocess

import yaml
import argparse


pca_to_board = {
    "PCA10056": "nrf52840dk_nrf52840",
    "PCA10100": "nrf52833dk_nrf52833",
    "PCA10112": "nrf21540dk_nrf52840",
    "PCA10059": "nrf52840dongle_nrf52840",
    "PCA10095": "nrf5340dk_nrf5340_cpuapp",
    "PCA20053": "thingy53_nrf5340_cpuapp",
}

family_to_pca = {
    "NRF52840": "PCA10056",
    "NRF52833": "PCA10100",
    "NRF21540": "PCA10112",
    "NRF52840DONGLE": "PCA10059",
    "NRF5340": "PCA10095",
    "THINGY53": "PCA20053",
}


def main(hardware_map_path: str, userdev_conf_path: str):
    """
    Generate HW map file for twister.

    :param hardware_map_path: Available HW generated by twister command:
                              --generate-hardware-map hardware-map.yaml --persistent-hardware-map
    :param userdev_conf_path: userdev_conf file describing installed HW or
                              AUTO key to generate hardware-map basis on connected HW
    :return:
    """
    if userdev_conf_path.upper() != "AUTO":
        with open(userdev_conf_path) as ud_file:
            userdev_conf = yaml.safe_load(ud_file)["devices"]

        # remove io_testers. We don't want to run tests on io_testers
        for ud_entry in userdev_conf:
            if ud_entry.get("boards", None):
                userdev_conf.remove(ud_entry)

    with open(hardware_map_path) as hw_file:
        hardware_map = yaml.safe_load(hw_file)
    to_remove = []
    for hw_entry in hardware_map:
        hw_entry["runner"] = "nrfjprog"
        hw_entry["connected"] = True
        segger = hw_entry["id"].lstrip("0")
        matched_pcas = []
        if userdev_conf_path.upper() != "AUTO":
            matched_pcas = [ud_entry["pca"] for ud_entry in userdev_conf if str(ud_entry.get("segger")) == segger]
        else:
            # recover DK
            recover = subprocess.run(["nrfjprog", "--recover", "--snr", segger], capture_output=True)
            if recover.returncode != 0:
                # it is OK to continue if recovery fail. This DK will not be taken to test
                continue
            # Read out device family
            out = subprocess.run(["nrfjprog", "--deviceversion", "--snr", segger], capture_output=True)
            matched_pcas = [family_to_pca[out.stdout.decode("utf-8").split("_")[0]]] if out.returncode == 0 else []
        if matched_pcas:
            try:
                hw_entry["platform"] = pca_to_board[matched_pcas[0]]
            except KeyError:
                # if platform not known, not supported - remove it
                to_remove.append(hw_entry)
                continue
            # Collect all entries for nRF53 DKs
            if "nrf5340dk_nrf5340_cpuapp" in hw_entry["platform"]:
                # If older nRF53 board (3 serial IFs), remove first and second serial interface
                if segger.startswith("9601"):
                    if "-if00" in hw_entry["serial"]:
                        to_remove.append(hw_entry)
                    elif "-if02" in hw_entry["serial"]:
                        to_remove.append(hw_entry)
                # If newer nRF53 board, remove only first serial interface
                elif segger.startswith("10500"):
                    if "-if00" in hw_entry["serial"]:
                        to_remove.append(hw_entry)
                else:
                    print("Unrecognized version of nRF53 board.")
        else:
            # HW not known or not connected. Mark for removal
            to_remove.append(hw_entry)

    # remove unuseful HW
    for item in to_remove:
        hardware_map.remove(item)

    with open(f"{hardware_map_path}_filled", "w") as hw_file:
        yaml.dump(hardware_map, hw_file)
    print("End")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="")

    parser.add_argument("hardware_map_path", type=str, help="")
    parser.add_argument("userdev_conf_path", type=str, help="")
    args = parser.parse_args()

    main(args.hardware_map_path, args.userdev_conf_path)
